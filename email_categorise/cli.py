from __future__ import annotations

import argparse
import logging
import subprocess
import uuid
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import List, Optional

from .codex_runner import CodexRunner
from .config import load_config, AccountConfig
from .triage_logic import init_account, run_for_account, rollback_run, send_failure_notification
from .utils import configure_logging, load_env_file, utc_now

logger = logging.getLogger("email_categorise.cli")


def _maybe_run_tests(cfg, accounts: List) -> None:
    """
    If tests haven't run in the last 7 days, run pytest.
    On failure: send notification and exit.
    """
    data_dir = Path(cfg.repo_root) / "data"
    data_dir.mkdir(parents=True, exist_ok=True)
    marker = data_dir / "last_tests.json"
    now = datetime.now(timezone.utc)
    meta = load_json(marker, {})
    last_run_str = meta.get("last_run")
    if last_run_str:
        try:
            last_run = datetime.fromisoformat(last_run_str)
            if now - last_run < timedelta(days=7):
                return
        except Exception:
            pass

    logger.info("Weekly test guard: running pytest...")
    result = subprocess.run(["pytest"], cwd=cfg.repo_root)
    if result.returncode == 0:
        save_json(marker, {"last_run": now.isoformat()})
        return

    logger.error("Pytest failed (exit %s); stopping execution.", result.returncode)
    sent = send_failure_notification(
        cfg,
        accounts,
        subject="Email categorise tests failing - run aborted",
        body_html=(
            "<p>Automated weekly tests failed. "
            "Triage run was aborted. Please check the logs and fix tests.</p>"
        ),
        run_id="tests",
    )
    if not sent:
        logger.error("Could not send failure notification email.")
    raise SystemExit("Tests failed; aborting run.")


def _select_accounts(accounts: List[AccountConfig], selected: Optional[List[str]]) -> List[AccountConfig]:
    if not selected:
        return accounts
    s = {x.lower() for x in selected}
    out = [a for a in accounts if a.email.lower() in s]
    if not out:
        raise SystemExit("No accounts matched -a filters")
    return out


def _write_report(repo_root: Path, name: str, content: str) -> Path:
    out_dir = repo_root / "output"
    out_dir.mkdir(parents=True, exist_ok=True)
    stamp = utc_now().strftime("%Y%m%d-%H%M%S")
    path = out_dir / f"email_categorise_{name}_{stamp}.last.md"
    path.write_text(content, encoding="utf-8")
    return path


def main() -> None:
    load_env_file()
    parser = argparse.ArgumentParser("email_categorise")
    sub = parser.add_subparsers(dest="cmd", required=True)

    default_config = Path(__file__).resolve().parent.parent / "config" / "config.toml"

    p_init = sub.add_parser("init")
    p_init.add_argument(
        "--config",
        "-c",
        default=str(default_config),
        help=f"Path to config TOML (default: {default_config})",
    )
    p_init.add_argument("-a", "--account", action="append")
    p_init.add_argument("-v", "--verbose", action="count", default=0)
    p_init.add_argument("--run-id", help="Optional run id for this init session")

    p_run = sub.add_parser("run")
    p_run.add_argument(
        "--config",
        "-c",
        default=str(default_config),
        help=f"Path to config TOML (default: {default_config})",
    )
    p_run.add_argument("-a", "--account", action="append")
    p_run.add_argument("-v", "--verbose", action="count", default=0)
    p_run.add_argument("--draft-replies", action=argparse.BooleanOptionalAction, dest="draft_replies", default=None, help="Enable/disable drafting replies for this run")
    p_run.add_argument("--create-tasks", action=argparse.BooleanOptionalAction, dest="create_tasks", default=None, help="Enable/disable task creation for this run")
    p_run.add_argument("--summary-email", action=argparse.BooleanOptionalAction, dest="summary_email", default=None, help="Enable/disable sending summary email for this run")
    p_run.add_argument("--log-to-file", action=argparse.BooleanOptionalAction, dest="log_to_file", default=None, help="Enable/disable writing triage-log.txt for this run")
    p_run.add_argument("--run-id", help="Optional run id; autogenerated if omitted (used for ledger/rollback)")
    p_run.add_argument("--undo-last", action="store_true", help="Rollback the most recent run recorded in the ledger")
    p_run.add_argument("--rollback", help="Rollback a specific run-id recorded in the ledger")

    args = parser.parse_args()
    configure_logging(args.verbose or 0)

    cfg = load_config(args.config)

    # Per-run overrides (do not persist)
    if args.cmd == "run":
        if args.draft_replies is not None:
            cfg.triage.draft_replies = bool(args.draft_replies)
        if args.create_tasks is not None:
            cfg.triage.create_tasks = bool(args.create_tasks)
        if args.summary_email is not None:
            cfg.triage.send_summary_email = bool(args.summary_email)
        if args.log_to_file is not None:
            cfg.triage.log_to_file = bool(args.log_to_file)

    accounts = _select_accounts(cfg.accounts, args.account)

    # Weekly test guard
    if args.cmd in {"run", "init"}:
        _maybe_run_tests(cfg, accounts)

    if args.cmd == "run" and (args.undo_last or args.rollback):
        ledger_dir = cfg.repo_root / "ledger"
        index_path = ledger_dir / "index.json"
        target_run = args.rollback
        if args.undo_last:
            index = load_json(index_path, {"order": []})
            order = index.get("order") or []
            if not order:
                raise SystemExit("No runs recorded in ledger to undo.")
            target_run = order[-1]
        if not target_run:
            raise SystemExit("No run-id provided for rollback.")
        res = rollback_run(cfg, accounts, target_run)
        print(f"Rollback complete for run {target_run}: {res}")
        return

    runner_triage = CodexRunner(repo_root=cfg.repo_root, provider=cfg.llm.provider, model=cfg.llm.triage_model)
    runner_reply = CodexRunner(repo_root=cfg.repo_root, provider=cfg.llm.provider, model=cfg.llm.reply_model)

    if args.cmd == "init":
        rows = []
        run_id = args.run_id or uuid.uuid4().hex[:12]
        for a in accounts:
            logger.info("Initialising %s (%s)", a.email, a.label)
            res = init_account(cfg, a, runner_reply, run_id=run_id)
            rows.append(res)
        md = "# init report\n\n" + "\n".join([f"- **{r['account']}**: sender_stats={r['sender_stats']}, tone_contacts={r['tone_contacts']}" for r in rows]) + "\n"
        report_path = _write_report(cfg.repo_root, "init", md)
        print(f"Report: {report_path}")
        return

    if args.cmd == "run":
        rows = []
        run_id = args.run_id or uuid.uuid4().hex[:12]
        for a in accounts:
            logger.info("Running triage for %s (%s)", a.email, a.label)
            res = run_for_account(cfg, a, runner_triage, runner_reply, run_id=run_id)
            rows.append(res)
        md_lines = ["# run report", ""]
        for r in rows:
            md_lines.append(f"- **{r['account']}**: processed={r.get('processed')}, drafts={r.get('drafts')}, tasks={r.get('tasks')}, informational={r.get('informational')}, summary_sent={r.get('summary_sent')}")
        md_lines.append("")
        report_path = _write_report(cfg.repo_root, "run", "\n".join(md_lines))
        print(f"Report: {report_path}")
        return
